using Bari.Core.Generic;
using Bari.Core.Model;
using Bari.Core.Test.Helper;
using Bari.Plugins.VCpp.Model;
using FluentAssertions;
using NUnit.Framework;

namespace Bari.Plugins.VCpp.Test.Model
{

    [TestFixture]
    public class SourceSetFilteringTest
    {
        private TestFileSystemDirectory sourceSetRoot;

        [SetUp]
        public void SetUp()
        {
            sourceSetRoot = new TestFileSystemDirectory("cpp");
        }

        [Test]
        public void FilesWithTlbExtensionAreFiltered()
        {
            var sourceSet = new SourceSet("cpp");
            sourceSet.Add(new SuiteRelativePath("x.cpp"));
            sourceSet.Add(new SuiteRelativePath("y.h"));
            sourceSet.Add(new SuiteRelativePath("a/b/c/z.c"));
            sourceSet.Add(new SuiteRelativePath("1.tlb"));
            sourceSet.Add(new SuiteRelativePath("a/2.tlb"));


            sourceSetRoot.SetFileContents("y.h", string.Empty);
            sourceSetRoot.SetFileContents("a/b/c/z.c", string.Empty);

            var filteredSet = sourceSet.FilterCppSourceSet(sourceSetRoot, sourceSetRoot);

            sourceSet.Files.Should().HaveCount(5);
            filteredSet.Files.Should().HaveCount(3);

            filteredSet.Files.Should().NotContain(new SuiteRelativePath("1.tlb"));
            filteredSet.Files.Should().NotContain(new SuiteRelativePath("a/2.tlb"));
        }

        [Test]
        public void FilesWithIdlExtensionAreFiltered()
        {
            var sourceSet = new SourceSet("cpp");
            sourceSet.Add(new SuiteRelativePath("x.cpp"));
            sourceSet.Add(new SuiteRelativePath("y.h"));
            sourceSet.Add(new SuiteRelativePath("a/b/c/z.c"));
            sourceSet.Add(new SuiteRelativePath("1.idl"));
            sourceSet.Add(new SuiteRelativePath("a/2.idl"));


            sourceSetRoot.SetFileContents("y.h", string.Empty);
            sourceSetRoot.SetFileContents("a/b/c/z.c", string.Empty);

            var filteredSet = sourceSet.FilterCppSourceSet(sourceSetRoot, sourceSetRoot);

            sourceSet.Files.Should().HaveCount(5);
            filteredSet.Files.Should().HaveCount(3);

            filteredSet.Files.Should().NotContain(new SuiteRelativePath("1.idl"));
            filteredSet.Files.Should().NotContain(new SuiteRelativePath("a/2.idl"));
        }

        [Test]
        public void GeneratedDllDataCIsFiltered()
        {
            var sourceSet = new SourceSet("cpp");
            sourceSet.Add(new SuiteRelativePath("x.cpp"));
            sourceSet.Add(new SuiteRelativePath("y.h"));
            sourceSet.Add(new SuiteRelativePath("real/dlldata.c"));
            sourceSet.Add(new SuiteRelativePath("fake/dlldata.c"));

            const string realDllDataC =
                @"/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/";

            const string fakeDllDataC = "this is just a regular file";

            sourceSetRoot.SetFileContents("real/dlldata.c", realDllDataC);
            sourceSetRoot.SetFileContents("fake/dlldata.c", fakeDllDataC);
            sourceSetRoot.SetFileContents("y.h", string.Empty);

            var filteredSet = sourceSet.FilterCppSourceSet(sourceSetRoot, sourceSetRoot);

            sourceSet.Files.Should().HaveCount(4);
            filteredSet.Files.Should().HaveCount(3);

            filteredSet.Files.Should().NotContain(new SuiteRelativePath("real/dlldata.c"));
            filteredSet.Files.Should().Contain(new SuiteRelativePath("fake/dlldata.c"));
        }

        [Test]
        public void GeneratedIdlHeaderIsFiltered()
        {
            var sourceSet = new SourceSet("cpp");
            sourceSet.Add(new SuiteRelativePath("x.cpp"));
            sourceSet.Add(new SuiteRelativePath("y.h"));
            sourceSet.Add(new SuiteRelativePath("real/something.h"));
            sourceSet.Add(new SuiteRelativePath("fake/something.h"));

            const string realIdlHeader = @"

/* this ALWAYS GENERATED file contains the definitions for the interfaces */

...";

            const string fakeIdlHeader = "this is just a regular file";

            sourceSetRoot.SetFileContents("real/something.h", realIdlHeader);
            sourceSetRoot.SetFileContents("fake/something.h", fakeIdlHeader);
            sourceSetRoot.SetFileContents("y.h", string.Empty);

            var filteredSet = sourceSet.FilterCppSourceSet(sourceSetRoot, sourceSetRoot);

            sourceSet.Files.Should().HaveCount(4);
            filteredSet.Files.Should().HaveCount(3);

            filteredSet.Files.Should().NotContain(new SuiteRelativePath("real/something.h"));
            filteredSet.Files.Should().Contain(new SuiteRelativePath("fake/something.h"));
        }

        [Test]
        public void GeneratedGuidDefinitionFileIsFiltered()
        {
            var sourceSet = new SourceSet("cpp");
            sourceSet.Add(new SuiteRelativePath("x.cpp"));
            sourceSet.Add(new SuiteRelativePath("y.h"));
            sourceSet.Add(new SuiteRelativePath("real/something.c"));
            sourceSet.Add(new SuiteRelativePath("fake/something.c"));

            const string realGuidDef = @"

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

...";

            const string fakeGuidDef = "this is just a regular file";

            sourceSetRoot.SetFileContents("real/something.c", realGuidDef);
            sourceSetRoot.SetFileContents("fake/something.c", fakeGuidDef);
            sourceSetRoot.SetFileContents("y.h", string.Empty);

            var filteredSet = sourceSet.FilterCppSourceSet(sourceSetRoot, sourceSetRoot);

            sourceSet.Files.Should().HaveCount(4);
            filteredSet.Files.Should().HaveCount(3);

            filteredSet.Files.Should().NotContain(new SuiteRelativePath("real/something.c"));
            filteredSet.Files.Should().Contain(new SuiteRelativePath("fake/something.c"));
        }

        [Test]
        public void GeneratedProxyStubIsFiltered()
        {
            var sourceSet = new SourceSet("cpp");
            sourceSet.Add(new SuiteRelativePath("x.cpp"));
            sourceSet.Add(new SuiteRelativePath("y.h"));
            sourceSet.Add(new SuiteRelativePath("real/something.c"));
            sourceSet.Add(new SuiteRelativePath("fake/something.c"));

            const string realProxyStub = @"

/* this ALWAYS GENERATED file contains the proxy stub code */

...";

            const string fakeProxyStub = "this is just a regular file";

            sourceSetRoot.SetFileContents("real/something.c", realProxyStub);
            sourceSetRoot.SetFileContents("fake/something.c", fakeProxyStub);
            sourceSetRoot.SetFileContents("y.h", string.Empty);

            var filteredSet = sourceSet.FilterCppSourceSet(sourceSetRoot, sourceSetRoot);

            sourceSet.Files.Should().HaveCount(4);
            filteredSet.Files.Should().HaveCount(3);

            filteredSet.Files.Should().NotContain(new SuiteRelativePath("real/something.c"));
            filteredSet.Files.Should().Contain(new SuiteRelativePath("fake/something.c"));
        }
    }
}