using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Xml;
using Bari.Core.Model;

namespace Bari.Plugins.VsCore.VisualStudio.ProjectSections
{
    /// <summary>
    /// Base class for MSBuild project file section listing the source files of the project
    /// </summary>
    public abstract class SourceItemsSectionBase: MSBuildProjectSectionBase
    {
        /// <summary>
        /// Initializes the class
        /// </summary>
        /// <param name="suite">Active suite</param>
        protected SourceItemsSectionBase(Suite suite) : base(suite)
        {
        }

        /// <summary>
        /// Writes the section using an XML writer
        /// </summary>
        /// <param name="writer">XML writer to use</param>
        /// <param name="project">The project to generate .csproj for</param>
        /// <param name="context">Current .csproj generation context</param>
        public override void Write(XmlWriter writer, Project project, IMSBuildProjectGeneratorContext context)
        {
            writer.WriteStartElement("ItemGroup");
            foreach (var sourceSet in GetSourceSets(project))
            {
                foreach (var file in sourceSet.Files)
                {
                    var relativePath = ToProjectRelativePath(project, file, ProjectSourceSetName);
                    var logicalPath = ToProjectRelativePath(project, file, sourceSet.Type);

                    // We have to skip .csproj files, which are generated by bari to the source set because otherwise
                    // VisualStudio does not work as expected:
                    if (!IgnoredExtensions.Any(ext => relativePath.EndsWith(ext, StringComparison.InvariantCultureIgnoreCase)))
                    {
                        writer.WriteStartElement(GetElementNameFor(file));
                        writer.WriteAttributeString("Include", relativePath);
                        
                        if (ProjectSourceSetName != sourceSet.Type)
                            writer.WriteElementString("LogicalName", logicalPath.Replace('\\', '.'));

                        writer.WriteEndElement();
                    }
                }
            }
            writer.WriteEndElement();
        }

        /// <summary>
        /// Gets the element name for a given compilation item.
        /// 
        /// <para>The default implementation always returns <c>Compile</c></para>
        /// </summary>
        /// <param name="file">File name from the source set</param>
        /// <returns>Returns a valid XML element name</returns>
        protected virtual string GetElementNameFor(string file)
        {
            Contract.Requires(file != null);

            return "Compile";
        }

        /// <summary>
        /// Gets the source sets to include 
        /// </summary>
        /// <param name="project">The project to get its source sets</param>
        /// <returns>Returns an enumeration of source sets, all belonging to the given project</returns>
        protected abstract IEnumerable<SourceSet> GetSourceSets(Project project);

        /// <summary>
        /// Gets a set of filename postfixes to be ignored when generating the source references
        /// </summary>
        protected abstract ISet<string> IgnoredExtensions { get; }

        /// <summary>
        /// Source set name where the project file is placed
        /// </summary>
        protected abstract string ProjectSourceSetName { get; }
    }
}